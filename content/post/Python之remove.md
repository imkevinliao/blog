---
title: "Python之remove"
date: 2021-11-11T21:26:47+08:00
draft: false
---

# remove
虽然平时经常会用for i in *来循环处理，但忽然看到下面这种情况就很值得玩味一番了。

```py
lis = [2,4,5,6,7]
for i in lis:
    if i % 2==0:
        lis.remove(i)
print(lis)

# 结果：
[4, 5, 7]
```

一开始的时候还觉得有些奇怪，不是很清楚为什么是这个结果。所以就去debug一步一步看，随即大悟。

在循环中的i表示的是该数组的下标，在debug过程中显示的是具体的值。一开始lis有5个元素，第一次循环的时候i=2，这个时候隐含的列表下表为0，这个元素是被移除的。

这个时候就很有意思了，移除后的lis的第一个元素变成了4，也就是列表下标为0的元素的值为4，可是我们第一次已经循环了列表下标为0的元素2，这个时候4就被跳过了，直接循环5这个元素。

后面当6元素被剔除的时候，猜猜看这个时候会不会循环7呢？答案是不会，因为此时的i所代表的隐藏下标已经越界了。

# 小结
可能有些乱，重新理一下吧。

在循环中的i（我们在debug的时候看到的是具体的数值），实际上应该理解为序列的下标，即index，而非value。这个lis有5个元素，那么i就是从0到4。不管lis的长度如何变化，i都是从0到4循环。不同的是列表在变化，所以对应的值也是在变化，就会出现轮空的情况，即有元素没有进行i % 2这个操作。

一句话，i指代的是index，可迭代序列的下标。